{"ast":null,"code":"import authAPI, { securityAPI } from \"../api/api.js\";\nconst SET_AUTH_USER = \"SET_AUTH_USER\";\nconst RESET_USER_AUTH_DATA = \"RESET_USER_AUTH_DATA\";\nconst GET_CAPTCHA_URL_SUCCESS = \"GET_CAPTCHA_URL_SUCCESS\";\nconst SET_ACCESS_TOKEN = \"SET_ACCESS_TOKEN\";\nconst SET_REFRESH_TOKEN = \"SET_REFRESH_TOKEN\";\nlet initialState = {\n  userId: null,\n  login: null,\n  email: null,\n  isAuth: false,\n  accessToken: \"\",\n  refreshToken: \"\"\n};\nconst AuthReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case SET_ACCESS_TOKEN:\n      return {\n        ...state,\n        accessToken: action.accessToken\n      };\n    case SET_REFRESH_TOKEN:\n      return {\n        ...state,\n        refreshToken: action.refreshToken\n      };\n    case SET_AUTH_USER:\n    case GET_CAPTCHA_URL_SUCCESS:\n      return {\n        ...state,\n        ...action.payload\n      };\n    case RESET_USER_AUTH_DATA:\n      return {\n        // ...state,\n        ...initialState\n      };\n    default:\n      return state;\n  }\n};\n_c = AuthReducer;\nexport default AuthReducer;\nexport const authUser = () => {\n  return async dispatch => {\n    try {\n      // console.log('Trying to authenticate...');\n      const response = await authAPI.authMe();\n      if (response.data.resultCode === 0) {\n        let {\n          id,\n          login,\n          email\n        } = response.data.data;\n        dispatch(setAuthUser(id, login, email, true));\n      }\n    } catch (error) {\n      // Если запрос к authMe завершился ошибкой, попробовать обновить токен\n      if (error.response && error.response.status === 403 && error.response.data.detail === \"Given token not valid for any token type\") {\n        try {\n          // console.log('Refreshing token...');\n          const refreshToken = localStorage.getItem('refreshToken'); // Получаем refresh token из localStorage\n\n          if (refreshToken) {\n            const response = await authAPI.refreshToken(refreshToken);\n            // console.log('New access token:', response.data.access);\n            localStorage.setAccessToken(response.data.access);\n            localStorage.setRefreshToken(response.data.refresh);\n\n            // Повторить запрос к authMe с новым access token\n            // console.log('Retrying authMe...');\n            const newResponse = await authAPI.authMe();\n            if (newResponse.data.resultCode === 0) {\n              let {\n                id,\n                login,\n                email\n              } = newResponse.data.data;\n              dispatch(setAuthUser(id, login, email, true));\n            }\n          }\n        } catch (refreshError) {\n          // console.error('Error refreshing token:', refreshError);\n          // Здесь вы можете выполнить какие-то дополнительные действия при неудачной попытке обновления токена\n          dispatch(resetAuthDataAC());\n          localStorage.setItem('userToken', '');\n          localStorage.setItem('refreshToken', '');\n        }\n      }\n    }\n  };\n};\nexport const register = (fullName, login, email, password, repidPassword, setStatus) => {\n  return async dispatch => {\n    const response = await authAPI.registerUser(fullName, login, email, password, repidPassword);\n    if (response.data.resultCode === 0) {\n      localStorage.setItem('userToken', response.data.data.token);\n      localStorage.setItem('refreshToken', response.data.data.refreshToken);\n      dispatch(authUser());\n    } else {\n      setStatus(response.data.email[0]);\n    }\n  };\n};\nexport const login = (username, password, setStatus) => {\n  return async dispatch => {\n    const response = await authAPI.loginUser(username, password);\n    console.log(response);\n    if (response.data.status === 200) {\n      // Сохранение токена в localStorage\n      // console.log('refreshToken', response.data.data.refreshToken)\n      localStorage.setAccessToken(response.data.access);\n      localStorage.setRefreshToken(response.data.refreshToken);\n      setAuthUser(true);\n    } else if (response.data.resultCode === 10) {\n      dispatch(getCaptchaUrl());\n    } else if (response.data.resultCode === 1) {\n      setStatus(response.data.messages[0]);\n    }\n  };\n};\nexport const getCaptchaUrl = () => async dispatch => {\n  const response = await securityAPI.getCaptchaUrl();\n  const captchaUrl = response.data.url;\n  dispatch(getCaptchaUrlSuccess(captchaUrl));\n};\nexport const logout = () => {\n  return async dispatch => {\n    try {\n      const response = await authAPI.logout();\n      if (response.data.resultCode === 0) {\n        dispatch(resetAuthDataAC());\n        localStorage.setItem('userToken', '');\n        localStorage.setItem('refreshToken', '');\n      }\n    } catch (error) {\n      // Обработка ошибок при выходе\n      console.error('Logout error:', error);\n    }\n  };\n};\n\n//Вывод стрелочной ф-и без return возможен, если функция только возвращает обьекты, после => нужно обернуть в ()\nexport const setAuthUser = (userId, login, email, isAuth) => ({\n  type: SET_AUTH_USER,\n  payload: {\n    userId,\n    login,\n    email,\n    isAuth\n  }\n});\nexport const getCaptchaUrlSuccess = captchaUrl => ({\n  type: GET_CAPTCHA_URL_SUCCESS,\n  payload: {\n    captchaUrl\n  }\n});\nexport const resetAuthDataAC = () => {\n  return {\n    type: RESET_USER_AUTH_DATA\n  };\n};\nexport const setAccessToken = accessToken => ({\n  type: SET_ACCESS_TOKEN,\n  accessToken\n});\nexport const setRefreshToken = refreshToken => ({\n  type: SET_REFRESH_TOKEN,\n  refreshToken\n});\nvar _c;\n$RefreshReg$(_c, \"AuthReducer\");","map":{"version":3,"names":["authAPI","securityAPI","SET_AUTH_USER","RESET_USER_AUTH_DATA","GET_CAPTCHA_URL_SUCCESS","SET_ACCESS_TOKEN","SET_REFRESH_TOKEN","initialState","userId","login","email","isAuth","accessToken","refreshToken","AuthReducer","state","action","type","payload","_c","authUser","dispatch","response","authMe","data","resultCode","id","setAuthUser","error","status","detail","localStorage","getItem","setAccessToken","access","setRefreshToken","refresh","newResponse","refreshError","resetAuthDataAC","setItem","register","fullName","password","repidPassword","setStatus","registerUser","token","username","loginUser","console","log","getCaptchaUrl","messages","captchaUrl","url","getCaptchaUrlSuccess","logout","$RefreshReg$"],"sources":["/home/dima_protasevich/Documents/PycharmProjects/student_app_test/frontend/src/reduser/auth-reduser.js"],"sourcesContent":["import authAPI, { securityAPI } from \"../api/api.js\";\n\nconst SET_AUTH_USER = \"SET_AUTH_USER\"\nconst RESET_USER_AUTH_DATA = \"RESET_USER_AUTH_DATA\"\nconst GET_CAPTCHA_URL_SUCCESS = \"GET_CAPTCHA_URL_SUCCESS\"\nconst SET_ACCESS_TOKEN = \"SET_ACCESS_TOKEN\";\nconst SET_REFRESH_TOKEN = \"SET_REFRESH_TOKEN\";\n\n\nlet initialState = {\n  userId: null,\n  login: null,\n  email: null,\n  isAuth: false,\n  accessToken: \"\",\n  refreshToken: \"\",\n};\n\nconst AuthReducer = (state = initialState, action) => {\n\n    switch (action.type) {\n\n        case SET_ACCESS_TOKEN:\n            return {\n                ...state,\n                accessToken: action.accessToken\n            }\n        \n        case SET_REFRESH_TOKEN:\n            return {\n              ...state,\n              refreshToken: action.refreshToken\n            };\n\n        case SET_AUTH_USER:\n        case GET_CAPTCHA_URL_SUCCESS:\n            return {\n                ...state, \n                ...action.payload\n                }\n\n        case RESET_USER_AUTH_DATA:\n            return {\n                // ...state,\n                ...initialState\n            }\n        \n        default:\n            return state\n    }\n}\n\nexport default AuthReducer\n\n\nexport const authUser = () => {\n    return async (dispatch) => {\n        try {\n            // console.log('Trying to authenticate...');\n            const response = await authAPI.authMe();\n\n            if (response.data.resultCode === 0) {\n                let { id, login, email } = response.data.data;\n                dispatch(setAuthUser(id, login, email, true));\n            }\n        } catch (error) {\n\n            // Если запрос к authMe завершился ошибкой, попробовать обновить токен\n            if (error.response && error.response.status === 403 && error.response.data.detail === \"Given token not valid for any token type\") {\n                try {\n                    // console.log('Refreshing token...');\n                    const refreshToken = localStorage.getItem('refreshToken'); // Получаем refresh token из localStorage\n\n                    if (refreshToken) {\n                        const response = await authAPI.refreshToken(refreshToken);\n                        // console.log('New access token:', response.data.access);\n                        localStorage.setAccessToken(response.data.access);\n                        localStorage.setRefreshToken(response.data.refresh);\n\n                        // Повторить запрос к authMe с новым access token\n                        // console.log('Retrying authMe...');\n                        const newResponse = await authAPI.authMe();\n                        if (newResponse.data.resultCode === 0) {\n                            let { id, login, email } = newResponse.data.data;\n                            dispatch(setAuthUser(id, login, email, true));\n                        }\n                    }\n                } catch (refreshError) {\n                    // console.error('Error refreshing token:', refreshError);\n                    // Здесь вы можете выполнить какие-то дополнительные действия при неудачной попытке обновления токена\n                    dispatch(resetAuthDataAC());\n                    localStorage.setItem('userToken', '');\n                    localStorage.setItem('refreshToken', '');\n                }\n            }\n        }\n    };\n};\n\n\nexport const register = (fullName, login, email, password, repidPassword, setStatus) => {\n    return async (dispatch) => {\n        const response = await authAPI.registerUser(fullName, login, email, password, repidPassword)\n        if (response.data.resultCode === 0) {\n            localStorage.setItem('userToken', response.data.data.token);\n            localStorage.setItem('refreshToken', response.data.data.refreshToken);\n            dispatch(authUser());\n        } else {\n            setStatus(response.data.email[0]);\n        }\n    }\n}\n\n\nexport const login = (username, password, setStatus) => {\n  return async (dispatch) => {\n    const response = await authAPI.loginUser(username, password);\n    console.log(response)\n    if (response.data.status === 200) {\n      // Сохранение токена в localStorage\n      // console.log('refreshToken', response.data.data.refreshToken)\n      localStorage.setAccessToken(response.data.access);\n      localStorage.setRefreshToken(response.data.refreshToken);\n\n      setAuthUser(true);\n    } else if (response.data.resultCode === 10) {\n      dispatch(getCaptchaUrl());\n    } else if (response.data.resultCode === 1) {\n      setStatus(response.data.messages[0]);\n    }\n  };\n};\n\n\nexport const getCaptchaUrl = () => async (dispatch) => {\n        const response = await securityAPI.getCaptchaUrl()\n        const captchaUrl = response.data.url\n        dispatch(getCaptchaUrlSuccess(captchaUrl))\n    }\n\nexport const logout = () => {\n    return async (dispatch) => {\n        try {\n            const response = await authAPI.logout();\n            if (response.data.resultCode === 0) {\n                dispatch(resetAuthDataAC());\n                localStorage.setItem('userToken', '');\n                localStorage.setItem('refreshToken', '');\n            }\n        } catch (error) {\n            // Обработка ошибок при выходе\n            console.error('Logout error:', error);\n        }\n    };\n};\n\n\n\n//Вывод стрелочной ф-и без return возможен, если функция только возвращает обьекты, после => нужно обернуть в ()\nexport const setAuthUser = (userId, login, email, isAuth) => ({ type: SET_AUTH_USER, payload: {userId, login, email, isAuth} })\nexport const getCaptchaUrlSuccess = (captchaUrl) => ({ type: GET_CAPTCHA_URL_SUCCESS, payload: {captchaUrl} })\nexport const resetAuthDataAC = () => {return { type: RESET_USER_AUTH_DATA }}\nexport const setAccessToken = (accessToken) => ({type: SET_ACCESS_TOKEN, accessToken})\nexport const setRefreshToken = (refreshToken) => ({type: SET_REFRESH_TOKEN, refreshToken})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}